<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Portafolio - Programaci√≥n Num√©rica</title>

  <style>
    /* Fondo degradado elegante */
    body {
      margin: 0;
      font-family: "Poppins", sans-serif;
      background: linear-gradient(135deg, #ffe6f2, #fad0c4, #fff0f6);
      color: #4a235a;
      line-height: 1.6;
      box-shadow: inset 0 0 20px rgba(255, 192, 203, 0.3);
      padding: 0 10%;
    }

    /* Animaci√≥n suave al aparecer */
    section {
      animation: fadeIn 1s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    h1 {
      text-align: center;
      margin-top: 40px;
      font-size: 36px;
      color: #d81b60;
    }

    h2, h3 {
      color: #ad1457;
      background: linear-gradient(to right, #f8bbd0, #fce4ec);
      padding: 8px 15px;
      border-radius: 15px;
    }

    h3 {
      margin-top: 25px;
    }

    pre {
      background: #fff5fa;
      border-left: 6px solid #f48fb1;
      padding: 15px;
      border-radius: 10px;
      font-family: "Consolas", monospace;
      color: #4a235a;
      overflow-x: auto;
      transition: transform 0.2s ease-in-out;
    }

    pre:hover {
      transform: scale(1.01);
    }

    footer {
      text-align: center;
      margin: 50px 0 30px;
      font-size: 14px;
      color: #6a1b9a;
      animation: glow 3s infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 0 0 5px #f48fb1; }
      to { text-shadow: 0 0 15px #f8bbd0; }
    }

    @media (max-width: 600px) {
      body { padding: 5%; font-size: 16px; }
      h1 { font-size: 28px; }
      h2 { font-size: 22px; }
      h3 { font-size: 18px; }
    }
  </style>
</head>

<!-- ENCABEZADO -->
<h1>üå∏ üíªCurso: Programaci√≥n Num√©rica üíªüå∏</h1>
<h2>Universidad Nacional del Altiplano - Puno</h2>
<h3>Facultad de Ingenier√≠a Estad√≠stica e Inform√°tica</h3>
<h3>üë©‚Äçüíª Estudiante: Gleny Angelica Condori Mamani üë©‚Äçüíª</h3>

<!-- üå∏ MEN√ö DE NAVEGACION -->
<nav style="
  background: linear-gradient(90deg, #f8bbd0, #fce4ec);
  padding: 15px 20px;
  border-radius: 30px;
  text-align: center;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  position: sticky;
  top: 0;
  z-index: 1000;
  font-family: 'Poppins', sans-serif;
  margin-top: 25px;
">

  <style>
    nav a {
      margin: 0 12px;
      text-decoration: none;
      color: #ad1457;
      font-weight: bold;
      transition: all 0.3s ease;
      border-radius: 8px;
      padding: 5px 8px;
    }

    nav a:hover {
      background: linear-gradient(to right, #f48fb1, #f8bbd0);
      color: white;
      box-shadow: 0 0 10px rgba(248, 187, 208, 0.6);
      transform: scale(1.08);
    }

    nav a:active {
      transform: scale(0.97);
      background: #d81b60;
      color: white;
    }

    /* L√≠nea divisoria m√°s sutil */
    nav span {
      color: #ec407a;
      font-weight: normal;
    }
  </style>

  <a href="#variables">Variables y Funciones</a> <span>|</span>
  <a href="#restricciones">Restricciones</a> <span>|</span>
  <a href="#ACTIVIDAD: Graficar restricciones">Actividad: Graficar Restricciones</a> <span>|</span>
  <a href="#metodos">M√©todos Num√©ricos</a> <span>|</span>
  <a href="#üîπ M√©todo de Newton-Raphson">M√©todo de Newton-Raphson</a> <span>|</span>
  <a href="#üîπ M√©todo de Bisecci√≥n">M√©todo de Bisecci√≥n</a> <span>|</span>
  <a href="#üîπ M√©todo de la Secante">M√©todo de la Secante</a> <span>|</span>
  <a href="#üîπ M√©todo de Punto Fijo">M√©todo de Punto Fijo</a> <span>|</span>
  <a href="#üîπ M√©todo de Regula Falsi (Falsa Posici√≥n)">M√©todo de Regula Falsi</a>
</nav>
  
<hr style="border: 2px solid #f06292; margin: 30px 0;">

<!-- ==================== -->
<!-- TEMA: VARIABLES Y FUNCIONES -->
<!-- ==================== -->
<section id="variables">
<h2>TEMA: VARIABLES Y FUNCIONES</h2>
<h3>üîπ ¬øQu√© es una variable?</h3>
<p>Una variable es un s√≠mbolo o elemento que puede cambiar de valor dentro de un problema o sistema. 
En estad√≠stica, una variable representa una caracter√≠stica que puede medirse u observarse y que var√≠a entre individuos o elementos de una poblaci√≥n. 
Ejemplo: edad, salario, temperatura, n√∫mero de fallas, tiempo de ejecuci√≥n de un programa. 
En inform√°tica, una variable es un espacio de memoria que guarda un valor que puede cambiar durante la ejecuci√≥n de un programa.</p>

<h3>üîπ ¬øQu√© es una funci√≥n?</h3>
<p>Una funci√≥n es una relaci√≥n entre variables, donde a cada valor de la variable independiente (x) le corresponde un solo valor de la variable dependiente (y). 
En estad√≠stica e ingenier√≠a, una funci√≥n se usa para modelar relaciones entre fen√≥menos. 
Ejemplo: y = 2x + 3 ‚Üí si x = 5, entonces y = 13. 
En inform√°tica, una funci√≥n es un bloque de c√≥digo reutilizable que realiza una tarea espec√≠fica y puede recibir datos (par√°metros) y retornar un resultado.</p>

<h3>üîπ ¬øD√≥nde se aplican en Ingenier√≠a Estad√≠stica e Inform√°tica?</h3>
<p><b>Campo:</b> Aplicaci√≥n de Variables y Funciones</p>

<table>
<tr><th>Ingenier√≠a Estad√≠stica</th><th>Ingenier√≠a Inform√°tica</th></tr>
<tr><td>- En modelos de regresi√≥n (relaci√≥n entre variables).<br>- En an√°lisis de datos (variables dependientes e independientes).<br>- En simulaciones y pron√≥sticos.</td>
<td>- En programaci√≥n (uso de variables y funciones en algoritmos).<br>- En desarrollo de software y bases de datos.<br>- En inteligencia artificial y an√°lisis de datos (funciones que transforman o procesan informaci√≥n).</td></tr>
</table>

<h3>üîπ Programa</h3>
<pre>
f(x,y) = 2y + x 
# Definimos la funci√≥n
def f(x, y):
    return 2 * y + x  
# Ejemplo de uso
x = float(input("Ingrese el valor de x: "))
y = float(input("Ingrese el valor de y: "))
resultado = f(x, y)
print("El resultado de f(x, y) = 2y + x es:", resultado)
</pre>
</section>

<!-- ==================== -->
<!-- TEMA: RESTRICCIONES -->
<!-- ==================== -->
<section id="restricciones">
<h2>TEMA: RESTRICCIONES</h2>
<p>Las restricciones son condiciones o limitaciones que debe cumplir un problema matem√°tico o de programaci√≥n lineal, delimitando la regi√≥n factible.</p>

<h3>üîπ 1 Tipos de Restricciones</h3>
<p><b>a) Restricciones de Igualdad:</b> Son condiciones que deben cumplirse exactamente.</p>
<p>Ejemplo: x + y = 10</p>

<p><b>b) Restricciones de Desigualdad:</b> Permiten l√≠mites m√°ximos o m√≠nimos.</p>
<p>Ejemplo: x + y ‚â§ 10</p>

<p><b>c) Restricciones de L√≠mites:</b> Definen un rango permitido para cada variable.</p>
<p>Ejemplo: 0 ‚â§ x ‚â§ 5</p>

<h3>üîπ 2. Sistemas de Ecuaciones</h3>
<p>Un sistema de ecuaciones es un conjunto de ecuaciones que tienen las mismas variables.</p>
<pre>
{x + y = 10
 2x - y = 5}
</pre>
<p>Soluci√≥n: x=5, y=5.</p>

<h3>ACTIVIDAD: Graficar restricciones</h3>
<p><b>EJERCICIOS PROPUESTOS:</b></p>

<ol>
  <li><b>Ejercicio 1:</b> Un desarrollador tiene 15 horas semanales para dedicar al desarrollo de software de front-end (x) y back-end (y). Adem√°s:
    <ul>
      <li>Debe dedicar al menos 5 horas al desarrollo de front-end.</li>
      <li>El tiempo total no puede exceder 15 horas.</li>
    </ul>
    <p><b>Tarea:</b> Formule las restricciones, repres√©ntelas gr√°ficamente e identifique las combinaciones posibles de tiempo.</p>
  </li>
  <li><b>Ejercicio 2:</b> Un ingeniero de datos administra dos tipos de servidores: A y B. El costo por hora de Servidor A es S/3 y de Servidor B es S/5. El presupuesto m√°ximo semanal es de S/20.
    <p><b>Tarea:</b> Determine cu√°ntas horas puede mantener activos cada tipo de servidor, formule el sistema y repres√©ntelo gr√°ficamente.</p>
  </li>
  <li><b>Ejercicio 3:</b> Un administrador de proyectos tecnol√≥gicos organiza su tiempo entre reuniones (x) y documentaci√≥n t√©cnica (y). Las reuniones requieren al menos 4 horas y la documentaci√≥n 6 horas. Si dispone de 12 horas:
    <p><b>Tarea:</b> Determine la regi√≥n factible y analice las combinaciones posibles de tiempo.</p>
  </li>
  <li><b>Ejercicio 4:</b> Una empresa de videojuegos produce Modelos 3D (P1) y Texturas (P2). Cada modelo requiere 2 horas y cada textura 3 horas. Se dispone de 18 horas.
    <p><b>Tarea:</b> Formule las restricciones, repres√©ntelas gr√°ficamente y determine cu√°ntos assets de cada tipo pueden producirse.</p>
  </li>
  <li><b>Ejercicio 5:</b> Una startup de hardware dispone de 50 unidades de componentes electr√≥nicos. Tipo A usa 5 unidades y tipo B usa 10.
    <p><b>Tarea:</b> Determine cu√°ntos dispositivos de cada tipo puede ensamblar sin exceder las 50 unidades.</p>
  </li>
</ol>

<pre>
# C√≥digo Python
import math
import re

def preparar_funcion(expr):
    # Quitar espacios
    expr = expr.replace(" ", "")
    # Insertar * donde falte (ej: 5x -> 5*x)
    expr = re.sub(r"(\d)([a-zA-Z])", r"\1*\2", expr)
    return expr

def graficar_restricciones(restricciones, fronteras, ancho=80, alto=25, escala=2):
    # Matriz vac√≠a
    plano = [[" " for _ in range(ancho)] for _ in range(alto)]

    # Dibujar ejes
    for x in range(ancho):
        plano[alto//2][x] = "-"  # eje X
    for y in range(alto):
        plano[y][ancho//2] = "|"  # eje Y
    plano[alto//2][ancho//2] = "+"  # origen

    # Sombrar regi√≥n factible
    for col in range(ancho):
        for fila in range(alto):
            x = (col - ancho//2) / escala
            y = (alto//2 - fila) / escala
            try:
                if all(eval(cond, {"x":x,"y":y,"math":math}) for cond in restricciones):
                    plano[fila][col] = "."
            except Exception:
                pass

    # Dibujar fronteras (rectas o verticales)
    simbolos = ["*", "#", "+", "x"]
    for idx, expr in enumerate(fronteras):
        expr = preparar_funcion(expr)
        simbolo = simbolos[idx % len(simbolos)]
        for col in range(ancho):
            x = (col - ancho//2) / escala
            try:
                y = eval(expr, {"x": x, "math": math})
                fila = int(alto//2 - y * escala)
                if 0 <= fila < alto:
                    plano[fila][col] = simbolo
            except Exception:
                # Interpretar como vertical x = constante
                try:
                    vx = float(expr)
                    col_v = int(round(vx * escala + ancho//2))
                    if 0 <= col_v < ancho:
                        for fila_v in range(alto):
                            plano[fila_v][col_v] = simbolo
                except Exception:
                    pass

    # Imprimir plano
    for fila in plano:
        print("".join(fila))

# EJERCICIO 1
print("\n=== Ejercicio 1: Desarrollador (front-end=x, back-end=y) ===")
restricciones_1 = [
    "x >= 5",
    "y >= 0",
    "x + y <= 15"
]
fronteras_1 = [
    "15 - x",  # x+y=15
    "0",       # y=0
    "5"        # x=5 (vertical)
]
graficar_restricciones(restricciones_1, fronteras_1)

# EJERCICIO 2
print("\n=== Ejercicio 2: Servidores (A=x, B=y) ===")
restricciones_2 = [
    "3*x + 5*y <= 20",
    "x >= 0",
    "y >= 0"
]
fronteras_2 = [
    "(20 - 3*x)/5",  # 3x+5y=20
    "0",
    "0"
]
graficar_restricciones(restricciones_2, fronteras_2)

# EJERCICIO 3
print("\n=== Ejercicio 3: Reuniones (x), Documentaci√≥n (y) ===")
restricciones_3 = [
    "x >= 4",
    "y >= 6",
    "x + y <= 12"
]
fronteras_3 = [
    "12 - x",  # x+y=12
    "6",       # y=6
    "4"        # x=4 (vertical)
]
graficar_restricciones(restricciones_3, fronteras_3)

# EJERCICIO 4
print("\n=== Ejercicio 4: Assets (Modelos=x, Texturas=y) ===")
restricciones_4 = [
    "2*x + 3*y <= 18",
    "x >= 0",
    "y >= 0"
]
fronteras_4 = [
    "(18 - 2*x)/3",  # 2x+3y=18
    "0",
    "0"
]
graficar_restricciones(restricciones_4, fronteras_4)

# EJERCICIO 5
print("\n=== Ejercicio 5: Componentes (A=x, B=y) ===")
restricciones_5 = [
    "5*x + 10*y <= 50",
    "x >= 0",
    "y >= 0"
]
fronteras_5 = [
    "(50 - 5*x)/10",  # 5x+10y=50
    "0",
    "0"
]
graficar_restricciones(restricciones_5, fronteras_5)

print("\n--- Fin de los gr√°ficos ---")
</pre>
</section>

<!-- ==================== -->
<!-- TEMA: M√âTODOS NUM√âRICOS PARA ENCONTRAR RA√çCES -->
<!-- ==================== -->
<section id="metodos">
<h2>TEMA: M√âTODOS NUM√âRICOS PARA ENCONTRAR RA√çCES</h2>
<p><b>Definici√≥n:</b> Se utilizan m√©todos num√©ricos para encontrar los valores de x que satisfacen f(x)=0, especialmente cuando no es posible resolver la ecuaci√≥n de manera algebraica.</p>

<h3>üîπ M√©todo de Newton-Raphson</h3>
<p>F√≥rmula: x‚Çô‚Çä‚ÇÅ = x‚Çô - f(x‚Çô)/f'(x‚Çô).<br>
Requiere derivada de la funci√≥n.<br>
Ventaja: r√°pido si la aproximaci√≥n inicial es buena.<br>
Desventaja: puede fallar si la derivada es cero o la aproximaci√≥n inicial est√° lejos de la ra√≠z.</p>

<h3>ACTIVIDAD: C√ìDIGO</h3>
<pre>
def f(x):
    return x**3 + x - 1

def df(x):
    return 3*x**2 + 1

def newton_raphson(x0, tol=1e-6, max_iter=100):
    xn = x0
    for n in range(max_iter):
        fxn = f(xn)
        dfxn = df(xn)
        if dfxn == 0:
            print("Derivada cero. No se puede continuar.")
            return None
        xn1 = xn - fxn/dfxn
        print(f"Iteraci√≥n {n+1}: x = {xn1}, f(x) = {f(xn1)}")
        if abs(xn1 - xn) < tol:
            print(f"\nLa ra√≠z aproximada es: {xn1}")
            return xn1
        xn = xn1
    print("No se alcanz√≥ la tolerancia requerida")
    return None

x0 = 0.5
newton_raphson(x0)
</pre>

<p><b>Interpretaci√≥n:</b> Este m√©todo aproxima la ra√≠z de una funci√≥n usando derivadas. Es ampliamente utilizado en ingenier√≠a para resolver ecuaciones no lineales con rapidez y precisi√≥n.</p>
</section>
<h3>üîπ M√©todo de Bisecci√≥n</h3>
<p>El <b>M√©todo de Bisecci√≥n</b> es un procedimiento num√©rico que permite encontrar una ra√≠z de una funci√≥n continua en un intervalo <i>[a, b]</i> donde los valores de la funci√≥n cambian de signo (es decir, f(a)¬∑f(b) &lt; 0).</p>

<p><b>F√≥rmula:</b><br>
Sea el punto medio m = (a + b) / 2.<br>
Si f(a)¬∑f(m) &lt; 0, entonces la ra√≠z est√° en [a, m].<br>
Si f(m)¬∑f(b) &lt; 0, entonces la ra√≠z est√° en [m, b].<br>
El proceso se repite hasta que el intervalo sea suficientemente peque√±o.</p>

<p><b>Ventajas:</b> M√©todo simple, seguro y siempre converge si se cumple el cambio de signo.<br>
<b>Desventajas:</b> Es m√°s lento comparado con Newton-Raphson.</p>

<h3>ACTIVIDAD: C√ìDIGO</h3>
<pre>
def f(x):
    return x**3 + x - 1  # Puedes cambiar la funci√≥n seg√∫n el ejercicio

def biseccion(a, b, tol=1e-6, max_iter=100):
    if f(a) * f(b) >= 0:
        print("El m√©todo no es aplicable: f(a) y f(b) deben tener signos opuestos.")
        return None

    for n in range(1, max_iter+1):
        m = (a + b) / 2
        fm = f(m)
        print(f"Iteraci√≥n {n}: a = {a:.6f}, b = {b:.6f}, m = {m:.6f}, f(m) = {fm:.6f}")

        if abs(fm) < tol or (b - a) / 2 < tol:
            print(f"\nLa ra√≠z aproximada es: {m:.6f}")
            return m

        if f(a) * fm < 0:
            b = m
        else:
            a = m

    print("No se alcanz√≥ la tolerancia requerida.")
    return None

# Ejemplo de uso:
a = 0
b = 1
biseccion(a, b)
</pre>

<p><b>Interpretaci√≥n:</b> Este m√©todo divide el intervalo en mitades sucesivas hasta encontrar una ra√≠z con la precisi√≥n deseada. 
Es muy usado en ingenier√≠a porque garantiza convergencia si existe cambio de signo entre los extremos del intervalo.</p>
<h3>üîπ M√©todo de la Secante</h3>
<p>El <b>M√©todo de la Secante</b> es una t√©cnica num√©rica para encontrar ra√≠ces de una funci√≥n 
que, a diferencia del m√©todo de Newton-Raphson, <b>no requiere calcular la derivada</b>. 
En lugar de usar f'(x), utiliza una aproximaci√≥n con dos puntos cercanos.</p>

<p><b>F√≥rmula:</b><br>
x‚Çô‚Çä‚ÇÅ = x‚Çô - f(x‚Çô) * (x‚Çô - x‚Çô‚Çã‚ÇÅ) / (f(x‚Çô) - f(x‚Çô‚Çã‚ÇÅ))</p>

<p><b>Ventajas:</b>  
‚Ä¢ No requiere derivadas.  
‚Ä¢ Converge m√°s r√°pido que la bisecci√≥n.  
<br>
<b>Desventajas:</b>  
‚Ä¢ Puede fallar si f(x‚Çô) ‚âà f(x‚Çô‚Çã‚ÇÅ).  
‚Ä¢ Menos estable que Newton-Raphson si la funci√≥n es irregular.</p>

<h3>ACTIVIDAD: C√ìDIGO</h3>
<pre>
def f(x):
    return x**3 + x - 1  # Puedes modificar la funci√≥n seg√∫n el problema

def secante(x0, x1, tol=1e-6, max_iter=100):
    for n in range(1, max_iter+1):
        f0 = f(x0)
        f1 = f(x1)
        if f1 - f0 == 0:
            print("Divisi√≥n por cero. No se puede continuar.")
            return None

        x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
        print(f"Iteraci√≥n {n}: x0 = {x0:.6f}, x1 = {x1:.6f}, x2 = {x2:.6f}, f(x2) = {f(x2):.6f}")

        if abs(x2 - x1) < tol:
            print(f"\nLa ra√≠z aproximada es: {x2:.6f}")
            return x2

        x0, x1 = x1, x2

    print("No se alcanz√≥ la tolerancia requerida.")
    return None

# Ejemplo de uso:
x0 = 0
x1 = 1
secante(x0, x1)
</pre>

<p><b>Interpretaci√≥n:</b> Este m√©todo aproxima la ra√≠z de una funci√≥n usando dos puntos sucesivos 
para estimar la pendiente de la curva. Es √∫til cuando no se dispone de la derivada y 
ofrece una buena velocidad de convergencia en comparaci√≥n con otros m√©todos b√°sicos.</p>
<h3>üîπ M√©todo de Punto Fijo</h3>
<p>El <b>M√©todo de Punto Fijo</b> transforma una ecuaci√≥n f(x)=0 en una forma equivalente x = g(x), 
donde se busca que las sucesivas iteraciones de g(x) converjan hacia la ra√≠z buscada. 
Este m√©todo es uno de los m√°s b√°sicos y se utiliza como base para otros m√©todos num√©ricos.</p>

<p><b>F√≥rmula general:</b><br>
x‚Çô‚Çä‚ÇÅ = g(x‚Çô)</p>

<p><b>Condici√≥n de convergencia:</b>  
El m√©todo converge si |g'(x)| &lt; 1 en el entorno de la ra√≠z.</p>

<p><b>Ventajas:</b><br>
‚Ä¢ F√°cil de implementar.<br>
‚Ä¢ No requiere derivadas.<br>
<b>Desventajas:</b><br>
‚Ä¢ Puede no converger si g(x) no est√° bien elegida.<br>
‚Ä¢ Requiere un an√°lisis previo de estabilidad.</p>

<h3>ACTIVIDAD: C√ìDIGO</h3>
<pre>
# Ejemplo: f(x) = cos(x) - x = 0
# Transformamos a la forma x = g(x) = cos(x)

import math

def g(x):
    return math.cos(x)

def punto_fijo(x0, tol=1e-6, max_iter=100):
    print(f"{'Iteraci√≥n':<10}{'x':<15}{'g(x)':<15}{'Error':<15}")
    print("-"*50)
    for n in range(1, max_iter+1):
        x1 = g(x0)
        error = abs(x1 - x0)
        print(f"{n:<10}{x1:<15.8f}{g(x1):<15.8f}{error:<15.8f}")

        if error < tol:
            print(f"\nLa ra√≠z aproximada es: {x1:.8f}")
            return x1
        x0 = x1
    print("\nNo se alcanz√≥ la tolerancia requerida.")
    return None

# Ejemplo de uso:
x0 = 0.5
punto_fijo(x0)
</pre>

<p><b>Interpretaci√≥n:</b>  
El m√©todo de Punto Fijo busca un valor que se mantenga invariable al aplicar g(x). 
En ingenier√≠a y estad√≠stica, se usa para resolver ecuaciones no lineales y modelos iterativos 
cuando es posible expresar la variable como una funci√≥n de s√≠ misma.</p>
<h3>üîπ M√©todo de Regula Falsi (Falsa Posici√≥n)</h3>
<p>El <b>M√©todo de Regula Falsi</b> o <b>M√©todo de la Falsa Posici√≥n</b> es una t√©cnica num√©rica para encontrar ra√≠ces de ecuaciones no lineales.  
Combina la idea del <b>M√©todo de Bisecci√≥n</b> con una <b>interpolaci√≥n lineal</b> para estimar la ra√≠z con mayor precisi√≥n.</p>

<p><b>F√≥rmula:</b><br>
x‚Çô = b - f(b) * (a - b) / (f(a) - f(b))</p>

<p><b>Procedimiento:</b><br>
1. Se eligen dos valores iniciales <b>a</b> y <b>b</b> tales que f(a)¬∑f(b) &lt; 0 (la ra√≠z est√° entre ellos).<br>
2. Se calcula una nueva aproximaci√≥n x‚Çô usando la f√≥rmula.<br>
3. Se reemplaza uno de los extremos por x‚Çô dependiendo del signo de f(x‚Çô).<br>
4. Se repite el proceso hasta cumplir la tolerancia deseada.</p>

<p><b>Ventajas:</b><br>
‚Ä¢ M√°s r√°pido que el m√©todo de bisecci√≥n.<br>
‚Ä¢ Siempre mantiene el intervalo que encierra la ra√≠z.<br>
<b>Desventajas:</b><br>
‚Ä¢ Puede converger lentamente si f(x) no cambia r√°pido de signo.</p>

<h3>ACTIVIDAD: C√ìDIGO</h3>
<pre>
def f(x):
    return x**3 - x - 2  # Ejemplo de funci√≥n

def regula_falsi(a, b, tol=1e-6, max_iter=100):
    if f(a) * f(b) >= 0:
        print("No se cumple el teorema del valor intermedio.")
        return None

    print(f"{'Iteraci√≥n':<10}{'a':<12}{'b':<12}{'x':<12}{'f(x)':<12}")
    print("-"*55)

    for n in range(1, max_iter + 1):
        x = b - (f(b) * (a - b)) / (f(a) - f(b))
        fx = f(x)
        print(f"{n:<10}{a:<12.6f}{b:<12.6f}{x:<12.6f}{fx:<12.6f}")

        if abs(fx) < tol:
            print(f"\nLa ra√≠z aproximada es: {x:.6f}")
            return x
        elif f(a) * fx < 0:
            b = x
        else:
            a = x
    print("\nNo se alcanz√≥ la tolerancia requerida.")
    return None

# Ejemplo de uso:
a = 1
b = 2
regula_falsi(a, b)
</pre>

<p><b>Interpretaci√≥n:</b>  
El m√©todo de Regula Falsi busca una ra√≠z dentro de un intervalo aplicando rectas secantes entre los puntos del intervalo.  
A diferencia del m√©todo de Bisecci√≥n, usa una interpolaci√≥n m√°s realista del comportamiento de la funci√≥n, lo que puede acelerar la convergencia.</p>

  <footer>
    <p>üå∏ Portafolio Acad√©mico - Programaci√≥n Num√©rica 2025 üå∏</p>
    <p>Universidad Nacional del Altiplano - Facultad de Ingenier√≠a Estad√≠stica e Inform√°tica</p>
  </footer>
</body>
</html>
